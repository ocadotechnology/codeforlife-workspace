#!/bin/bash

# A CLI for each backend service.
#  - The 1st arg is the name of the function.
#  - All the remaining args are the arguments of the function.

# ------------------------------------------------------------------------------
# Variables
# ------------------------------------------------------------------------------

# The path to the backend directory in the workspace.
backend_dir=".workspace/backend"

# The path of the pyproject.toml.
pyproject_toml="$backend_dir/pyproject.toml"

# The path of the source code.
source=${SOURCE:-"."}

export PIPENV_VERBOSITY="${PIPENV_VERBOSITY:--1}"

# Shorthand for the mypy CLI.
# https://mypy.readthedocs.io/en/stable/command_line.html
mypy="pipenv run mypy --config-file=$pyproject_toml"

# Shorthand for the isort CLI.
# https://pycqa.github.io/isort/docs/configuration/options.html
isort="pipenv run isort --settings-file=$pyproject_toml"

# Shorthand for the black CLI.
# https://black.readthedocs.io/en/stable/usage_and_configuration/the_basics.html
black="pipenv run black --config=$pyproject_toml"

# Shorthand for the pylint CLI.
# https://pylint.pycqa.org/en/stable/user_guide/configuration/all-options.html
pylint="pipenv run pylint --rcfile=$pyproject_toml"

# Shorthand for the django CLI.
django="pipenv run python manage.py"

# Shorthand for the pytest CLI.
# https://docs.pytest.org/en/8.3.x/reference/reference.html
# https://pytest-xdist.readthedocs.io/en/stable/distribution.html
pytest="pipenv run pytest -c=$pyproject_toml -n=auto"

# ------------------------------------------------------------------------------
# Private/Utility Functions
# ------------------------------------------------------------------------------

function _count_files() { echo "$@" | wc -l; }

function _pipe_py_files_to_cli() {
  if [[ ! -v all_py_files ]]; then
    # Find all the relevant Python files and cache them in a global variable.
    all_py_files=$(
      find $source \
        -type f \
        -name "*.py" \
        -not -path "*/.venv/*" \
        -not -path "*/.workspace/*" \
        -not -path "*/migrations/*"
    )

    # Find the subset of Python files that are and aren't tests and cache them
    # in global variables.
    local test_py_file_name="*_test.py"
    test_py_files=$(find $all_py_files -name "$test_py_file_name")
    non_test_py_files=$(find $all_py_files -not -name "$test_py_file_name")
  fi

  # Lazy load the desired set of Python files by the set's name.
  local set_name="${set_name:-"all"}_py_files"
  local py_files=${!set_name}

  # Apply additional filtering to the Python files
  if [[ -v find ]]; then py_files=$(find $py_files $find); fi

  # Echo the number of files and the raw command.
  echo_debug Piping $(_count_files "$py_files") files to command:
  echo_cmd "$@"

  # Pipe the files to the command.
  find $py_files -print0 | xargs -0 $@
}

function _make_pytest_options() {
  local options="$@"

  if ! eval_bool "${DJANGO:-1}"; then options+=" -p no:django"; fi

  # https://pytest-cov.readthedocs.io/en/latest/config.html
  if eval_bool "${coverage:-0}"; then options+=" --cov=$source"; fi

  echo "$options"
}

# ------------------------------------------------------------------------------
# Public/Callable Functions
# ------------------------------------------------------------------------------

function setup() {
  # Setup your local environment.
  echo_and_run_cmd pipenv install --dev
}

function hard_install() {
  function cleanup() {
    if [ -f "Pipfile.lock" ]; then echo "Deleting Pipfile.lock"; fi
    echo_and_run_cmd rm -f Pipfile.lock

    if [ -e ".venv" ]; then echo "Deleting .venv"; fi
    echo_and_run_cmd rm -rf .venv
    echo_and_run_cmd mkdir .venv
    echo_and_run_cmd touch .venv/.gitkeep
  }

  callback="cleanup" step Cleaning up PY environment
  callback="setup" step Setting up PY environment
  return $exit_code
}

function imports:check() {
  # Check imports order.
  _pipe_py_files_to_cli $isort --check
}

function format() {
  # Format code.
  _pipe_py_files_to_cli $black
}

function format:check() {
  # Check formatting issues.
  _pipe_py_files_to_cli $black --check
}

function types:check() {
  # Check static types.
  _pipe_py_files_to_cli $mypy
}

function code:check:non_tests {
  # Find linting issues in non-test files.
  set_name="non_test" _pipe_py_files_to_cli $pylint
}

function code:check:tests() {
  # Find linting issues in test files.
  set_name="test" _pipe_py_files_to_cli $pylint --disable=duplicate-code
}

function code:check() {
  # Find linting issues.
  callback="code:check:non_tests" step Linting non-test files
  callback="code:check:tests" step Linting test files
  return $exit_code
}

function migrations:check() {
  # Check no pending Django migrations.
  # https://docs.djangoproject.com/en/4.2/ref/django-admin/#django-admin-makemigrations
  echo_and_run_cmd $django makemigrations --check --dry-run
}

function test() {
  # Run tests.
  echo_and_run_cmd $pytest $(_make_pytest_options "$@ $source")
}

function test:coverage:report() {
  # Run tests and generate coverage report.
  coverage=1 test --cov-report=xml:coverage.xml
}

function test:coverage:check() {
  # Run tests and check coverage thresholds.
  coverage=1 test --cov-fail-under=90
}

function test:coverage() {
  if github_repo_owner_is_ocado_tech; then
    test:coverage:report $@
  else
    test:coverage:check $@
  fi
}

function packages:check() {
  snyk:test --command=.venv/bin/python --policy-path="$backend_dir/.snyk"
}

function run:django() {
  # Run a local Django server.
  callback="setup" step Setting up PY environment
  function callback() {
    SERVER_MODE="django" echo_and_run_cmd \
      $django runserver localhost:${SERVICE_PORT:-"8000"}
  }
  step Running Django development server
  return $exit_code
}

function check() {
  # Run all checks.
  callback="setup" step Setting up PY environment
  callback="imports:check" step Checking imports
  callback="format:check" step Checking format
  callback="types:check" step Checking types
  callback="code:check" step Checking code
  callback="migrations:check" step Checking Django migrations
  callback="test" step Running tests
  if eval_bool "${packages:-0}"; then
    callback="packages:check" step Checking packages
  fi
  return $exit_code
}

# ------------------------------------------------------------------------------
# Entrypoint
# ------------------------------------------------------------------------------

# Must be the last line in the script!
eval "$(.workspace/.scripts/main run_script $(readlink -f "$0") $@)"
